---
title: "EventedArray: Served Two Ways"
date: 2013-11-11 19:30
author: Darren
tags: Code, CoffeeScript, JavaScript, Underscore
description: "Listening to events on an array-like data structure in an Object Oriented and Functional way"
keywords: javascript, coffeescript, underscore, programming
image: "underscorejs.png"
---

<%= entry_asset({:url => 'http://images.darrenknewton.com/underscorejs.png', :alt => 'UnderscoreJS', :title => "Underscore.JS | Underscore-Contrib"}) %>

This post takes a quick look at creating a custom Array-like data
structure in [CoffeeScript](http://coffeescript.org/) that allows you to register callbacks on
accessor/mutator operations. Along the way I make a small diversion
into functional programming land. The final project is on
[GitHub](https://github.com/DarrenN/EventedArray). READMORE

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="/js/mylibs/underscore/underscore-min.js"></script>
<script src="/js/mylibs/EventedArray.js"></script>
<script src="/js/mylibs/Box.js"></script>
<script src="/js/mylibs/Photo.js"></script>
<style type="text/css" media="screen">
    #drawing {
        width: 100%;
        height: 400px;
        border: #ddd 1px solid;
        background: #fff;
    }
    #displayqueue {
        text-align: center;
        font-family: 'Inconsolata', 'Menlo', 'Courier', monospace;
        color: #666;
        margin: 20px;
    }
</style>

## Background

The concept of
[Reactive Programming](https://en.wikipedia.org/wiki/Reactive_programming)
has been gaining a lot of traction lately, especially when working with
user interfaces. To oversimplify, Reactive Programming deals with streams of data or events which can be sampled,
combined and observed to try an bring order to the chaos found in your
typical web application. A lot of very smart folks have written some
excellent libraries to achieve this, such as
[RxJS](http://reactive-extensions.github.io/RxJS/) and
[Bacon.js](https://github.com/baconjs/bacon.js). Go check 'em out.

When I'm working on small applications I often find I need an
"observable" data structure. It would be great to have something like
an array which I could treat like a stack, with events triggered
whenever values are pushed on or shifted off. I could achieve this
with either of the libraries noted above, or even Backbone.js's [Events](http://backbonejs.org/docs/backbone.html#section-13)
mixin, but sometimes I just need something small and simple.

## EventedArray

I wanted this data structure to be as close to a regular
[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
as possible, with a standard Object Oriented type interface. The [core
library](https://github.com/DarrenN/EventedArray/blob/master/source/coffee/EventedArray.coffee) is written in CoffeeScript, but its geared to be used in
vanilla JS all the way:

    :::javascript
    // Create a new data structure
    var E = new EventedArray(1,2,3,4);

    // It has setters & getters
    E.set(5,6);
    E.get(4); // returns 5, the 0 indexed value of the array
    E.toString(); // "[1,2,3,4,5,6]"

    // Remove values
    E.remove(3);
    E.toString(); // "[1,2,4,5,6]"

    // Mess with the stack
    E.pop();
    E.toString(); // "[1,2,4,5]"
    E.shift(); // 1
    E.toString(); // "[2,4,5]"

    // Underscore collection functions
    E.each(function(i){ console.log(i*i); }); // 4 16 25
    E.map(function(i){ return i^2; }); // [0,6,7]
    E.filter(function(i){ return i%2 == 0; }); // [2,4]

    // Raw access to the values
    E.values; // [2,4,5]

So that's cool, it behaves like an Array for the most part. Now I want
to add some callbacks that are triggered when I set, get, shift, etc.

    :::javascript
    E.register('set', function(i){ console.log(i + ' was set on E'); });
    E.set(6); // '6 was set on E'

    E.register('remove', function(i){ console.log(i + ' was removed!'); });
    E.remove(2); // '2 was removed!'

A lot of times I want to treat my data structure like a fixed size
stack, something that will only hold _n_ values, shifting older values
off the front as new ones are pushed onto the end. So I went ahead and
added a `setBuffer` method to do just that:

    :::javascript
    var E = new EventedArray();
    E.setBuffer(5);
    E.set(1,2,3,4,5,6);
    E.toString(); // "[2,3,4,5,6]"
    E.set(7,8,9,10);
    E.toString(); // "[6,7,8,9,10]"

## Demo time!

So what can we do with EventedArray? It really lends itself to
managing streams of values, so here's a little DOM based animation
example. Go ahead and waggle your cursor around in the box:

<iframe src="/js/mylibs/test-animation.html" style="width: 100%;
height: 410px; overflow: hidden" />

The code for this is pretty simple, we have one EventedArray with a
buffer of 25 storing the boxes and a listener on the `mousemove` event
passing those Boxes in:

    :::javascript
    // Create a queue to display our points
    var displayQueue = $('#displayqueue');
    var P = new EventedArray();
    P.setBuffer(25);
    // When points are set to this queue display them as a string
    P.register('set', function() { displayQueue.html(P.toString()); });

    // Create a Queue that holds 25 items and attach events
    var Q = new EventedArray();
    Q.setBuffer(25);

    // As Boxes are set tell them to appear and also set their
    // [x,y] to the displayQueue
    Q.register('set', function(b) { b.showBox(); P.set(b.point) });

    // As boxes are shifted off, tell them to fade out
    // and null them out
    Q.register('shift', function(b) { b.hideBox(); b = null; });

    // Drawing area
    var canvas = $('#drawing');

    // Mousemove listener
    var onMove = function(e) {
      Q.set(new Box([e.x, e.y], canvas));
    };
    document.getElementById('drawing').addEventListener('mousemove', onMove);

So this nice, Boxes are pushed into the queue and shifted off, with
events triggering their behavior. You could wire up more elaborate
systems using this general concept, such as
[this one](http://darrenn.github.io/EventedArray/tests-jsonp.html)
which filters items from one EventedArray into another:

<iframe src="/js/mylibs/tests-jsonp.html" style="width: 100%;
height: 390px; overflow: hidden" />

## Closure Flavored

EventedArray is a nice little data structure that manages its own
internal states with a simple interface. Could we do the same thing in
a purely functional manner without creating an object? Sure. It's a
little messier but pretty easy to achieve. Instead of creating an
object that manages its values, we use
[higher order functions](https://en.wikipedia.org/wiki/Higher-order_function)
to close over some Arrays, creating new functions that do what we need (in CoffeeScript):

    :::coffeescript
    ###
    #  Higher order functions which return functions that operate
    #  on the data structures they close over.
    ###

    registerListener = (list, f) -> list.push f

    # Create a function which sets a value onto
    # coll and keeps coll within size, removing
    # any values exceeding that size
    buffer = (size, coll, set, remove) ->
      (item) ->
        set item
        if coll.length > size then remove()
        coll

    # Return a function which sets a value onto the end of coll
    # and triggers any callbacks in listeners
    setter = (coll, listeners) ->
      (items...) ->
        items.forEach (i) ->
          coll.push i
          if listeners? then listeners.forEach (l) -> l i
        coll

    # Return a function which shifts values from coll
    # and triggers any callbacks in listeners
    remover = (coll, listeners) ->
      ->
        o = coll.shift()
        if listeners? then listeners.forEach (l) -> l o
        coll

    # Return a function which looks for values in
    # coll by numeric index and triggers any callbacks
    # in listeners
    getter = (coll, listeners) ->
      (index) ->
        i = if coll[index]? then coll[index] else undefined
        if listeners? then listeners.forEach (l) -> l i
        i

We could then setup the same animated box example by building our
queues like so - [live example](http://darrenn.github.io/EventedArray/test-fanimation.html):

    :::coffeescript
    ###
    #  Queues
    ###

    # Display x/y tuples
    # ==================

    $displayQueue = $('#displayqueue')
    dlist         = []
    dset          = setter dlist, [(i) -> $displayQueue.html(JSON.stringify(dlist))]
    dpop          = remover dlist, []
    dQueue        = buffer 25, dlist, dset, dpop

    # Display boxes
    # =============

    $canvas  = $('#drawing');
    blist    = []
    showBox  = (b) -> b.showBox() # tell the box to render
    addPoint = (b) -> dQueue b.point # add x/y to $displayQueue
    bset     = setter blist, [showBox, addPoint]
    bpop     = remover blist, [(b) -> b.hideBox(); b = null]
    bQueue   = buffer 25, blist, bset, bpop

    # Capture MouseMove
    onMove = (e) ->
      bQueue new Box([e.x, e.y], $canvas)

    document.getElementById('drawing').addEventListener('mousemove', onMove);

The functional version isn't as fully-featured as EventedArray (and
requires more setup), but it does illustrate a different way to think
about the problem and this concept is a lot easier to transfer to a
language like [ClojureScript](https://github.com/clojure/clojurescript), which I've been playing around with lately.

[^1]: Thanks for the [clarification!](http://www.reddit.com/r/javascript/comments/1dscmr/functional_tricks_with_underscorecontrib/c9te10l)

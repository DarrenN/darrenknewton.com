---
title: "EventedArray: Served Two Ways"
date: 2013-11-11 19:30
author: Darren
tags: Code, CoffeeScript, JavaScript, Underscore
description: "Listening to events on an array-like data structure in an Object Oriented and Functional way"
keywords: javascript, coffeescript, underscore, programming
image: "underscorejs.png"
---

<%= entry_asset({:url => 'http://images.darrenknewton.com/underscorejs.png', :alt => 'UnderscoreJS', :title => "Underscore.JS | Underscore-Contrib"}) %>

This post takes a quick look at creating a custom Array-like data
structure in CoffeeScript that allows you to register callbacks on
accessor/mutator operations. Along the way I make a small diversion
into functional programming land. The final project is on
[GitHub](https://github.com/DarrenN/EventedArray). READMORE

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="/js/mylibs/underscore/underscore-min.js"></script>
<script src="/js/mylibs/EventedArray.js"></script>
<script src="/js/mylibs/Box.js"></script>
<script src="/js/mylibs/Photo.js"></script>
<style type="text/css" media="screen">
    #drawing {
        width: 100%;
        height: 400px;
        border: #ddd 1px solid;
        background: #fff;
    }
    #displayqueue {
        text-align: center;
        font-family: 'Inconsolata', 'Menlo', 'Courier', monospace;
        color: #666;
        margin: 20px;
    }
</style>

## Background

The concept of
[Reactive Programming](https://en.wikipedia.org/wiki/Reactive_programming)
has been gaining a lot of traction lately, especially when working with
user interfaces. To oversimplify, Reactive Programming deals with streams of data or events which can be sampled,
combined and observed to try an bring order to the chaos found in your
typical web application. A lot of very smart folks have written some
excellent libraries to achieve this, such as
[RxJS](http://reactive-extensions.github.io/RxJS/) and
[Bacon.js](https://github.com/baconjs/bacon.js). Go check 'em out.

When I'm working on small applications I often find I need an
"observable" data structure. It would be great to have something like
an array which I could treat like a stack, with events triggered
whenever values are pushed on or shifted off. I could achieve this
with either of the libraries noted above, or even Backbone.js's [Events](http://backbonejs.org/docs/backbone.html#section-13)
mixin, but sometimes I just need something small and simple.

## EventedArray

I wanted this data structure to be as close to a regular
[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
as possible, with a standard Object Oriented type interface. The core
library is written in [CoffeeScript](https://github.com/DarrenN/EventedArray/blob/master/source/coffee/EventedArray.coffee), but its geared to be used in
vanilla JS all the way:

    :::javascript
    // Create a new data structure
    var E = new EventedArray(1,2,3,4);

    // It has setters & getters
    E.set(5,6);
    E.get(4); // returns 5, the 0 indexed value of the array
    E.toString(); // "[1,2,3,4,5,6]"

    // Remove values
    E.remove(3);
    E.toString(); // "[1,2,4,5,6]"

    // Mess with the stack
    E.pop();
    E.toString(); // "[1,2,4,5]"
    E.shift(); // 1
    E.toString(); // "[2,4,5]"

    // Underscore collection functions
    E.each(function(i){ console.log(i*i); }); // 4 16 25
    E.map(function(i){ return i^2; }); // [0,6,7]
    E.filter(function(i){ return i%2 == 0; }); // [2,4]

    // Raw access to the values
    E.values; // [2,4,5]

So that's cool, it behaves like an Array for the most part. Now I want
to add some callbacks that are triggered when I set, get, shift, etc.

    :::javascript
    E.register('set', function(i){ console.log(i + ' was set on E'); });
    E.set(6); // '6 was set on E'

    E.register('remove', function(i){ console.log(i + ' was removed!'); });
    E.remove(2); // '2 was removed!'

A lot of times I want to treat my data structure like a fixed size
stack, something that will only hold _n_ values, shifting older values
off the front as new ones are pushed onto the end. So I went ahead and
added a `setBuffer` method to do just that:

    :::javascript
    var E = new EventedArray();
    E.setBuffer(5);
    E.set(1,2,3,4,5,6);
    E.toString(); // "[2,3,4,5,6]"
    E.set(7,8,9,10);
    E.toString(); // "[6,7,8,9,10]"

## Demo time!

So what can we do with EventedArray? It really lends itself to
managing streams of values, so here's a little DOM based animation
example. Go ahead and waggle your cursor around in the box:

<div id="drawing"></div>
<div id="displayqueue"></div>

<script>
    // Create a Queue that holds 25 items and attach events
    var Q = new EventedArray();
    Q.setBuffer(25);
    Q.register('set', function(b) { b.showBox(); });
    Q.register('shift', function(b) { b.hideBox(); delete(b); });

    // Create another queue to display our points
    var displayQueue = $('#displayqueue');
    var P = new EventedArray();
    P.setBuffer(25);
    P.register('set', function() { displayQueue.html(P.toString()); });

    // Drawing area
    var canvas = $('#drawing');
    var offset = canvas.offset();
    var canvasOffsetTop = offset.top - (canvas.height() / 2) + 40;
    var canvasOffsetLeft = offset.left - (canvas.width() / 2) + 40;

    // Mousemove listener
    var onMove = function(e) {
      Q.set(new Box([canvasOffsetLeft + e.x, canvasOffsetTop + e.y], canvas));
      P.set([e.x, e.y]);
    };

    document.getElementById('drawing').addEventListener('mousemove', onMove);
</script>

[^1]: Thanks for the [clarification!](http://www.reddit.com/r/javascript/comments/1dscmr/functional_tricks_with_underscorecontrib/c9te10l)
